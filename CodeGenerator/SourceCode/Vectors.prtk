PRATEEK_CODEGEN_FILE_INFO(Vectors, cs)
{
    PRATEEK_CODEGEN_BLOCK_SWIZZLE(Prateek.Extensions, VectorExt)
    {
        PRATEEK_CODEGEN_CLASS(Vector2, x, y)
        PRATEEK_CODEGEN_CLASS(Vector3, x, y, z)
        PRATEEK_CODEGEN_CLASS(Vector4, x, y, z, w)

        PRATEEK_CODEGEN_DEFAULT(float, 0)

        PRATEEK_CODEGEN_CODE_PREFIX
        {
        @//---------------------------------------------------------------------
        @#region Swizzle SRC_CLASS to DST_CLASS
        }

        PRATEEK_CODEGEN_CODE_MAIN
        {
        @public static DST_CLASS SWIZZLE_CALL(this SRC_CLASS SWIZZLE_ARGS) { return new DST_CLASS(SWIZZLE_VARS); }
        }
        
        PRATEEK_CODEGEN_CODE_SUFFIX
        {
        @#endregion Swizzle SRC_CLASS to DST_CLASS
		@
        }
    }

    PRATEEK_CODEGEN_BLOCK_MIXED_CTOR(Prateek.ShaderTo, CSharp)
    {
        PRATEEK_CODEGEN_CLASS(Vector2, vec2, x, y)
        PRATEEK_CODEGEN_CLASS(Vector3, vec3, x, y, z)
        PRATEEK_CODEGEN_CLASS(Vector4, vec4, x, y, z, w)

        PRATEEK_CODEGEN_DEFAULT(float, 0)

        PRATEEK_CODEGEN_CODE_PREFIX
        {
        @//---------------------------------------------------------------------
        @#region Mixed Ctor SRC_CLASS
        }

        PRATEEK_CODEGEN_CODE_MAIN
        {
        @public static SRC_CLASS MIXED_CTOR_CALL(MIXED_CTOR_ARGS) { return new SRC_CLASS(MIXED_CTOR_VARS); }
        }
        
        PRATEEK_CODEGEN_CODE_SUFFIX
        {
        @#endregion Mixed Ctor SRC_CLASS
		@
        }
    }
//Mixed constructors
//
//public static SRC_CLASS MIXED_CTOR_CALL(MIXED_CTOR_ARGS) { return new SRC_CLASS(MIXED_CTOR_VARS); }
//
//public static Vector2 vec2(float n_0, float n_1) { return new Vector2(n_0, n_1); }

//namespace ShaderTo
//{
//    public static class CSharp
//    {
//        public static float max(float v) { return Mathf.Max(v); }
//        public static float min(float v) { return Mathf.Min(v); }
//        public static float mul(float v, float b) { return v * b; }
//        public static float div(float v, float b) { return v / b; }
//        public static float abs(float v, float b) { return Mathf.Abs(v); }
//        public static float sign(float v) { return Mathf.Sign(v); }
//        public static float area(float v) { return v * v; }
//        public static int index(float v) { return v * v; }
//        public static float exp(float v) { return Mathf.Exp(v); }
//        public static float cos(float v) { return Mathf.Cos(v); }
//        public static float sin(float v) { return Mathf.Sin(v); }
//        public static float floor(float v) { return Mathf.Floor(v); }
//        public static float fract(float v) { return v - floor(v); }
//        public static float sqrt(float v) { return Mathf.Sqrt(v); }
//
//        public static Vector2 vec2(float v) { return Vector2.one * v; }
//        public static Vector3 vec3(Vector2 v0, float v1) { return new Vector3(v0.x, v0.y, v1); }
//        public static Vector4 vec4(Vector2 v0, float v1, float v2) { return new Vector4(v0.x, v0.y, v1, v2); }
//        public static Vector2 normalize(Vector2 v) { return v.normalized; }
//        public static Vector3 normalize(Vector3 v) { return v.normalized; }
//        public static Vector4 normalize(Vector4 v) { return v.normalized; }
//
//        public static float hash(float seed) { return fract(sin(seed) * 43758.5453f); }
//
//    }
//}
}
